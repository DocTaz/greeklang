import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.commons.io.FilenameUtils
import edu.unc.epidoc.transcoder.TransCoder




buildscript {
  repositories {
    mavenCentral()
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {
    classpath group: 'org.apache.commons', name: 'commons-io', version: '1.3.2'
    classpath group : 'edu.unc.epidoc', name: 'transcoder', version : '1.2-SNAPSHOT'
  }
}


// Generates appropriate statement to add to makefile dependencies
// for lexica.
String lexiconMakeStatement(File dir) {
  StringBuilder stmt = new StringBuilder()
  def fileList = []
  dir.eachFileMatch(~/.*.fst/) { fstFile ->
    fileList.add ("${buildDir}/fst/${fstFile.getName()}".toString())
  }
  fileList.each { f ->
    stmt.append(f + " ")
  }
  return stmt.toString()
}

// Generates appropriate SFST-PL statements for including lexica
// in .fst files.
String lexiconFstStatement(File dir) {
  StringBuilder stmt = new StringBuilder()
  def fileList = []

  dir.eachFileMatch(~/.*.fst/) { fstFile ->
    //fileList.add ('"' + "${projectDir}/${fstFile.getName()}".toString() + '"')
    fileList.add ('"' + "${buildDir}/fst/${fstFile.getName()}".toString() + '"')
  }
  fileList.eachWithIndex { f, i ->
    if (i < (fileList.size() - 1)) {
      stmt.append( f + ' | ')
    } else {
      stmt.append( f )
    }

  }
  return stmt.toString()
}




// Generates appropriate SFST-PL statements for including
// compiled inflectional rules.
String rulesFstStatement(File dir) {
  StringBuilder stmt = new StringBuilder()
  def fileList = []
  dir.eachFileMatch(~/.*.fst/) { fstFile ->
    String compiledFile = fstFile.getName().replaceFirst(/fst$/, "a")
    fileList.add ('"<' + "${buildDir}/fst/${compiledFile}".toString() + '>"')
  }
  fileList.eachWithIndex { f, i ->
    if (i < (fileList.size() - 1)) {
      stmt.append( f + ' | ')
    } else {
      stmt.append( f )
    }

  }
  return stmt.toString()
}

// Generates appropriate statements for makefile
// dependencies on compiled inflectional rules.
String rulesMakeStatement(File dir) {
  StringBuilder stmt = new StringBuilder()
  def fileList = []
  dir.eachFileMatch(~/.*.fst/) { fstFile ->
    String compiledFile = fstFile.getName().replaceFirst(/fst$/, "a")
    fileList.add ("${buildDir}/fst/${compiledFile}".toString())
  }
  fileList.each { f ->
    stmt.append(f + " ")
  }
  return stmt.toString()
}



task cpSrc (type: Copy) {
    description = "Filters and copies src directory to build area."
    from ("src/fst") {
      include ("makefile", "**/*.fst")
    }
    into "${buildDir}/fst"
    filter(
      ReplaceTokens, tokens: [
      "workdir" : buildDir.toString() + "/fst/",
      "lexica": lexiconFstStatement(new File("${projectDir}/${stemsdir}")),
      "makelexica": lexiconMakeStatement(new File("${projectDir}/${stemsdir}")),
      "extrafstrules": rulesFstStatement(new File("${projectDir}/${rulesdir}")),
      "extramakerules": rulesMakeStatement(new File("${projectDir}/${rulesdir}"))
     ])
}

task cpRules (type: Copy) {
    description = "Filters and copies directory with additional inflectional rules to build area."
    from ("rules") {
      include ("**/*.fst")
    }
    into "${buildDir}/fst"
    filter(ReplaceTokens, tokens: ["workdir" : "${buildDir}/fst/".toString()])
}


task cpStems (type: Copy) {
    description = "Filters adn copies directory with lexica of stems to build area."
    from ("stems") {
      include ('**/*.fst')
    }
    into "${buildDir}/fst"
    filter(ReplaceTokens, tokens: ["workdir" : "${buildDir}/fst/".toString()])
}


task cpTags (type: Copy) {
    description = "Filters and copies directory with taxonomic tags to build area."
    from ("urnregistry") {
      include ('**/*.fst')
    }
    into "${buildDir}/fst"
    filter(ReplaceTokens, tokens: ["workdir" : "${buildDir}/fst/".toString()])
}


task cpAll (dependsOn: [cpTags, cpStems, cpRules, cpSrc]){
  description = "Copies all source material to build area"
}
cpAll.doLast {
  System.err.println "All source files copied to build area."
}

task fst(type:Exec, dependsOn: cpAll) {
  description = "Builds binary Finite State Transducer in ${buildDir}/fst/greek.a"

  outputs.file "${buildDir}/fst/greek.a".toString()
  inputs.dir "${buildDir}/fst"

  commandLine =  [MAKE, "-f", "${buildDir}/fst/makefile".toString()]
}


task fstgen(type:Exec, dependsOn: cpAll) {
  description = "Builds binary Finite State Transducer in ${buildDir}/fst/greek.a and 'switched' FST (for bulk generation of surface symbols) in ${buildDir}/fst/bulkgen.a"

  outputs.file "${buildDir}/fst/bulkgen.a".toString()
  inputs.dir "${buildDir}/fst"

  commandLine =  [FSTCOMPILER, "-s", "${buildDir}/fst/morphology.fst".toString(), "${buildDir}/fst/bulkgen.a".toString()]
}



task rawlex(type:Exec, dependsOn: fst) {
  description = "Builds binary Finite State Transducer in ${buildDir}/fst/rawlex.a"

  outputs.file "${buildDir}/fst/rawlex.a".toString()
  inputs.file "${buildDir}/fst/fst.a"

  commandLine =  [FSTCOMPILER, "${buildDir}/fst/rawlex.fst".toString(), "${buildDir}/fst/rawlex.a".toString()]
}

task rawmorph(type:Exec, dependsOn: fst) {
  description = "Builds binary Finite State Transducer in ${buildDir}/fst/rawmorph.a"

  outputs.file "${buildDir}/fst/rawmorph.a".toString()
  inputs.file "${buildDir}/fst/fst.a"

  commandLine =  [FSTCOMPILER, "${buildDir}/fst/rawmorph.fst".toString(), "${buildDir}/fst/rawmorph.a".toString()]
}

task rawaccepted(type:Exec, dependsOn: fst) {
  description = "Builds binary Finite State Transducer in ${buildDir}/fst/rawaccepted.a"

  outputs.file "${buildDir}/fst/rawaccepted.a".toString()
  inputs.file "${buildDir}/fst/fst.a"

  commandLine =  [FSTCOMPILER, "${buildDir}/fst/rawaccepted.fst".toString(), "${buildDir}/fst/rawaccepted.a".toString()]
}

task utils(dependsOn: [rawlex, rawmorph, rawaccepted]) {
  description = "Compiles utility transducers useful for debugging"
}
utils.doLast {
  System.err.println "Utilities compiled."
}



task cpTestLists (type: Copy) {
  description = "Copies word lists for tests to work area"
  from ("testing/wordlists") {
    include ('**/*.txt')
  }
  into "${buildDir}/tests/wordlists"
}
cpTestLists.doLast {
  System.err.println "Word lists for tests copied to work area"
}

task buildTestTokens(dependsOn: [cpTestLists]) {
  description = "Convert UTF-8 word lists to FST tokens"
  inputs.dir file("${buildDir}/tests/wordlists")
  outputs.dir file("${buildDir}/tests/tokens")
}
buildTestTokens.doLast {
  TransCoder utf2beta = new TransCoder()
  utf2beta.setParser("Unicode")
  utf2beta.setConverter("BetaCode")


  def tokensDir = new File("${buildDir}/test/tokens")
  if (! tokensDir.exists()) {
    tokensDir.mkdir()
  }
  def listsDir = file("${buildDir}/tests/wordlists")
  listsDir.eachFileMatch(~/.*.txt/) { utf8file ->
    String listText = utf8file.getText("UTF-8")
    String tokenized = utf2beta.getString(listText).replaceAll(/[=\\/\\\\]/,"").toLowerCase()
    String baseName = FilenameUtils.getName(utf8file.toString())
    File tokensFile = new File(
      "${buildDir}/tests/tokens/${baseName}"
      )
    tokensFile.setText(tokenized)
    System.err.println "Added tokens for ${baseName}"
  }

}



task testFST(dependsOn: buildTestTokens) {
  description = "Runs FST on test word lists and analyzes results."
  //outputs.file "${buildDir}/fst/bulkgen.a".toString()
  inputs.dir file("${buildDir}/tests/tokens")
  outputs.file file("${buildDir}/tests/report.txt")
}
testFST.doLast{
  def tokensDir = file("${buildDir}/tests/tokens")
  StringBuffer rept = new StringBuffer()
  tokensDir.eachFileMatch(~/.*.txt/) { tokens ->
    def cmd = "${FSTINFL} ${buildDir}/fst/greek.a ${tokens}"
    Process process = cmd.execute()
    def out = new StringBuffer()
    def err = new StringBuffer()
    process.consumeProcessOutput( out, err )
    process.waitFor()
    System.err.println "Analyze file: ${tokens}"
    rept.append(out.toString())

  }

  File reptFile = new File("${buildDir}/tests/report.txt")
  reptFile.setText(rept.toString())
}

// To do this dynamically we need to invoke the
// jvm classes compiled for this subproject
/*
task analyzeFSTTests(dependsOn: testFST){
  description = "Reads output of testFST task and generates analytical report"
}
analyzeFSTTests.doLast {
  System.err.println "Analyzed results of FST testing"
}
*/


task setupCoreTests(type: Copy, dependsOn: 'fst') {
  from ("${buildDir}")
  into "fst_tests/build"
}


task install() {
  description = "Install binary fst parser and CLI scripts in /usr/local"
}
